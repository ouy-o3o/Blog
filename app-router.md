## 文件系统

next 的路由基于文件系统，相似的概念类似于 umi 里的 page router。 在 next 里 page 就是 index。 类似于在 pages 目录下创建一个 about.js 文件 映射的路由就是/about

# App Router

## 路由定义

路由定义文件是路由的入口，文件名就是路由的路径，文件内容是路由的配置。文件夹被用来定义路由，举个例子，/user/setting 路由对应的路由定义文件是根目录下的 user/setting 根目录默认是 app，完整的路径就是 app/user/setting。

## 定义页面 ( page )

在 next 中 默认约定 `page` 或者 `index` 为页面的访问文件。
上面例子里的 /user/setting 路由对应的页面就是 app/user/setting/page.js 或者 app/user/setting/index.js。

一个文件夹里可以不写 page 文件或者 index 文件，这样的文件夹不会被 next 识别为路由，当然不止 `.js` next 默认是支持 React、TypeScript 的所以 `jsx`、`tsx` 文件也是可以的。

page.js 文件写法

```js
import { useRouter } from "next/router";

export default function Setting() {
  const router = useRouter();
  return (
    <div>
      <h1>Setting</h1>
      <button onClick={() => router.push("/user/profile")}>
        Go to Profile
      </button>
    </div>
  );
}
```

## 定义布局 ( layout )

布局是指多个页面共享的 UI，布局会保留状态、保持可交互性并且不会重新渲染。b 端常见的是管理系统的左侧菜单导航栏和顶部的状态栏。c 端常见的是底部的菜单栏。

定义布局首先你要新建一个 layout.js 文件, 默认导出一个 React 组件，组件应接受一个`children` prop，`children` 表示子页面。还是用上面的`setting.js`举个例子 只要在 app/user/setting/下 新建 layout.js 文件，文件内容如下

```js
import React from "react";

export default function Layout({ children }) {
  return (
    <div>
      <h1>Setting Layout</h1>
      {children}
    </div>
  );
}
```

当访问`/user/setting`,效果如下
![app-router-p1](https://github.com/ouy-o3o/Blog/assets/83851692/d205adab-3b00-40cb-8eae-451ddff19937)

你会发现 同一个文件夹下如果有 layout 和 page 文件 page 文件会作为 children 参数传入 layout 文件内。
而且 layout 是支持嵌套的，我们在 user 文件夹下新增一个 layout 文件，代码如下

```js
import React from "react";

export default function Layout({ children }) {
  return (
    <div>
      <h1>User Layout</h1>
      {children}
    </div>
  );
}
```

还是访问`/user/setting` 效果如下
![app-router-p2](https://github.com/ouy-o3o/Blog/assets/83851692/2279f53b-3425-4046-98e2-9c9d6c603e85)

### 根布局 (App Layout)

布局支持嵌套，最顶层的布局我们成为 根布局，也就是`app/layout.js` 它会应用在所有的路由上，除此之外，它还有点特殊。 使用`create-next-app` 默认创建的 `layout.js` 代码如下

```js
// app/layout.js
import "./globals.css";
import { Inter } from "next/font/google";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}
```

特殊点

1. `app` 目录必须包含根目录
2. 根布局必须包含`html` `body` 标签，其他的布局不能包含这些标签。。
3. 默认根布局是服务端组件，且不支持设置为客户端组件

## 定义模板 （template）

模板和布局类似。也会传入每个子布局或者页面，但他不会维持状态

模板在切换时 会为每一个 children 创建一个实例，也就意味着用户在共享一个模板的路由之间跳转的时候，将会重新挂载组件实例，重新创建 dom 元素， 不再保留状态。

定义模板 我们需要先创建一个名为 `template.js` 的文件，这个文件默认导出一个 React 组件，组件接受一个`children` prop，

```js
// app/template.js
export default function Template({ children }) {
  return <div>{children}</div>;
}
```

用法和 layout 一样，如果同一个目录下既有`template.js` 又有 `layout.js` 最后的输出结果

```js
<Layout>
  <Template>{children}</Template>
</Layout>
```

布局会包裹模板，模板包裹页面
比较适合使用模板的情况，比如：依赖 useEffect 和 useState 记录用户访问数

## 定义加载页面 （Loading）

和名称一样，loading 就是加载中页面，next 这个功能实现主要借用了 react 的 Suspense ，效果就是当路由变化的时候立刻展示 fallback UI ,等待数据加载完成后直接展示数据

```js
// app/loading.js
// 在 ProfilePage 组件处于加载阶段时显示 Spinner
<Suspense fallback={<Spinner />}>
  <ProfilePage />
</Suspense>
```

简单来说，ProfilePage 会 throw 一个数据加载的 Promise，Suspense 会捕获它，然后追加一个 then 函数，在 then 函数里替换 fallback UI。

简单写一个 loading.js

```js
// user/loading.tsx
export default function UserLoading() {
  return <>Loading User Info...</>;
}
```

```js
// user/page.tsx
import React, { FC } from "react";
async function getData() {
  await new Promise((resolve) => setTimeout(resolve, 3000));
  return {
    message: "Hello, Ouy!",
  };
}
interface Props {}
const Index: FC<Props> = async () => {
  const { message } = await getData();
  return <h1>{message}</h1>;
};
export default Index;
```

很简单， 关键在于`page` 页面导出了一个`async`函数
`loading.js` 的实现原理是将 `page.js`和下面的 `children` 用 `<Suspense>` 包裹。因为`page.js`导出一个 async 函数，Suspense 得以捕获数据加载的 promise，借此实现了 loading 组件的关闭。
也可以不导出一个 async 函数，可以使用`React`的`use`函数，代码如下

```js
import React, { FC, use } from "react";

async function getData() {
  await new Promise((resolve) => setTimeout(resolve, 5000));
  return {
    message: "Hello, About!",
  };
}

const Index: FC = () => {
  const { message } = use(getData());
  return <h1>{message}</h1>;
};
export default Index;
```

如果一个文件夹下又有 template 又有 layout 又有 loading 他们渲染出来的层级是怎么样的呢

![app-router-p3](https://github.com/ouy-o3o/Blog/blob/next/assets/app-router-p3.png?raw=true)

# 平行路由

可用与在同一个布局中同时或有条件的渲染一个或多个页面，类似于 Vue 的插槽

## 条件渲染

![app-router-p3](https://github.com/ouy-o3o/Blog/blob/next/assets/dynamic-routes-4.webp?raw=true)
